# coding: utf-8

"""
    VIRL STD API

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)

    OpenAPI spec version: 0.10
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import sys
import os
import re

# python 2 and python 3 compatibility library
from six import iteritems

from ..configuration import Configuration
from ..api_client import ApiClient


class TrafficCaptureApi(object):
    """
    NOTE: This class is auto generated by the swagger code generator program.
    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        config = Configuration()
        if api_client:
            self.api_client = api_client
        else:
            if not config.api_client:
                config.api_client = ApiClient()
            self.api_client = config.api_client

    def simengine_rest_capture_simulation_delete(self, simulation, capture, **kwargs):
        """
        Delete a traffic capture.
        Delete a traffic capture. Traffic captures will remain defined as long as the simulation exists, unless they are removed by this call, even if they are no longer, running due to reaching their limits, or if an error occurred. The captured data in offline captures is deleted as well.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.simengine_rest_capture_simulation_delete(simulation, capture, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str simulation: Simulation ID (required)
        :param str capture: select a specific capture (required)
        :return: StdDefsJsondefinitionsnoschema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.simengine_rest_capture_simulation_delete_with_http_info(simulation, capture, **kwargs)
        else:
            (data) = self.simengine_rest_capture_simulation_delete_with_http_info(simulation, capture, **kwargs)
            return data

    def simengine_rest_capture_simulation_delete_with_http_info(self, simulation, capture, **kwargs):
        """
        Delete a traffic capture.
        Delete a traffic capture. Traffic captures will remain defined as long as the simulation exists, unless they are removed by this call, even if they are no longer, running due to reaching their limits, or if an error occurred. The captured data in offline captures is deleted as well.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.simengine_rest_capture_simulation_delete_with_http_info(simulation, capture, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str simulation: Simulation ID (required)
        :param str capture: select a specific capture (required)
        :return: StdDefsJsondefinitionsnoschema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['simulation', 'capture']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simengine_rest_capture_simulation_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'simulation' is set
        if ('simulation' not in params) or (params['simulation'] is None):
            raise ValueError("Missing the required parameter `simulation` when calling `simengine_rest_capture_simulation_delete`")
        # verify the required parameter 'capture' is set
        if ('capture' not in params) or (params['capture'] is None):
            raise ValueError("Missing the required parameter `capture` when calling `simengine_rest_capture_simulation_delete`")


        collection_formats = {}

        path_params = {}
        if 'simulation' in params:
            path_params['simulation'] = params['simulation']

        query_params = []
        if 'capture' in params:
            query_params.append(('capture', params['capture']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/simengine/rest/capture/{simulation}', 'DELETE',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StdDefsJsondefinitionsnoschema',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def simengine_rest_capture_simulation_get(self, simulation, **kwargs):
        """
        List available traffic captures, or fetch captured data.
        List available traffic captures, or fetch captured data. Only offline captures can fetch their stored data, and can do so repeatedly, even if the traffic capture isn't running anymore.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.simengine_rest_capture_simulation_get(simulation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str simulation: Simulation ID (required)
        :param str capture: select a specific capture
        :param str accept: `application/vnd.tcpdump.pcap` download capture data
        :return: StdDefsJsondefinitionsnoschema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.simengine_rest_capture_simulation_get_with_http_info(simulation, **kwargs)
        else:
            (data) = self.simengine_rest_capture_simulation_get_with_http_info(simulation, **kwargs)
            return data

    def simengine_rest_capture_simulation_get_with_http_info(self, simulation, **kwargs):
        """
        List available traffic captures, or fetch captured data.
        List available traffic captures, or fetch captured data. Only offline captures can fetch their stored data, and can do so repeatedly, even if the traffic capture isn't running anymore.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.simengine_rest_capture_simulation_get_with_http_info(simulation, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str simulation: Simulation ID (required)
        :param str capture: select a specific capture
        :param str accept: `application/vnd.tcpdump.pcap` download capture data
        :return: StdDefsJsondefinitionsnoschema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['simulation', 'capture', 'accept']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simengine_rest_capture_simulation_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'simulation' is set
        if ('simulation' not in params) or (params['simulation'] is None):
            raise ValueError("Missing the required parameter `simulation` when calling `simengine_rest_capture_simulation_get`")


        collection_formats = {}

        path_params = {}
        if 'simulation' in params:
            path_params['simulation'] = params['simulation']

        query_params = []
        if 'capture' in params:
            query_params.append(('capture', params['capture']))

        header_params = {}
        if 'accept' in params:
            header_params['Accept'] = params['accept']

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/simengine/rest/capture/{simulation}', 'GET',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StdDefsJsondefinitionsnoschema',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)

    def simengine_rest_capture_simulation_post(self, simulation, node, interface, **kwargs):
        """
        Create a new traffic capture
        Create a new traffic capture process attached to a running node interface. A traffic capture is either offline, collected to a file on the VIRL server, or live, exposing a TCP port on the VIRL server where the data can be collected. The capture process is subject to limits on the amounts of traffic that can be captures. If the client does not set these limits, the maximum allowed by server config is used.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.simengine_rest_capture_simulation_post(simulation, node, interface, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str simulation: Simulation ID (required)
        :param str node: select node where the traffic is captured by name (required)
        :param str interface: select interface by ID or `management` keyword (required)
        :param int live_port: Expose live capture on this port, 0 = automatic
        :param str pcap_filter: filter captured traffic using a PCAP filter
        :param int count: capture max `count` packets
        :param int size: capture max `size` MB of traffic
        :param int time: capture max `time` seconds of traffic
        :return: StdDefsJsondefinitionsnoschema
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('callback'):
            return self.simengine_rest_capture_simulation_post_with_http_info(simulation, node, interface, **kwargs)
        else:
            (data) = self.simengine_rest_capture_simulation_post_with_http_info(simulation, node, interface, **kwargs)
            return data

    def simengine_rest_capture_simulation_post_with_http_info(self, simulation, node, interface, **kwargs):
        """
        Create a new traffic capture
        Create a new traffic capture process attached to a running node interface. A traffic capture is either offline, collected to a file on the VIRL server, or live, exposing a TCP port on the VIRL server where the data can be collected. The capture process is subject to limits on the amounts of traffic that can be captures. If the client does not set these limits, the maximum allowed by server config is used.
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please define a `callback` function
        to be invoked when receiving the response.
        >>> def callback_function(response):
        >>>     pprint(response)
        >>>
        >>> thread = api.simengine_rest_capture_simulation_post_with_http_info(simulation, node, interface, callback=callback_function)

        :param callback function: The callback function
            for asynchronous request. (optional)
        :param str simulation: Simulation ID (required)
        :param str node: select node where the traffic is captured by name (required)
        :param str interface: select interface by ID or `management` keyword (required)
        :param int live_port: Expose live capture on this port, 0 = automatic
        :param str pcap_filter: filter captured traffic using a PCAP filter
        :param int count: capture max `count` packets
        :param int size: capture max `size` MB of traffic
        :param int time: capture max `time` seconds of traffic
        :return: StdDefsJsondefinitionsnoschema
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['simulation', 'node', 'interface', 'live_port', 'pcap_filter', 'count', 'size', 'time']
        all_params.append('callback')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method simengine_rest_capture_simulation_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'simulation' is set
        if ('simulation' not in params) or (params['simulation'] is None):
            raise ValueError("Missing the required parameter `simulation` when calling `simengine_rest_capture_simulation_post`")
        # verify the required parameter 'node' is set
        if ('node' not in params) or (params['node'] is None):
            raise ValueError("Missing the required parameter `node` when calling `simengine_rest_capture_simulation_post`")
        # verify the required parameter 'interface' is set
        if ('interface' not in params) or (params['interface'] is None):
            raise ValueError("Missing the required parameter `interface` when calling `simengine_rest_capture_simulation_post`")


        collection_formats = {}

        path_params = {}
        if 'simulation' in params:
            path_params['simulation'] = params['simulation']

        query_params = []
        if 'node' in params:
            query_params.append(('node', params['node']))
        if 'interface' in params:
            query_params.append(('interface', params['interface']))
        if 'live_port' in params:
            query_params.append(('live-port', params['live_port']))
        if 'pcap_filter' in params:
            query_params.append(('pcap-filter', params['pcap_filter']))
        if 'count' in params:
            query_params.append(('count', params['count']))
        if 'size' in params:
            query_params.append(('size', params['size']))
        if 'time' in params:
            query_params.append(('time', params['time']))

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []

        return self.api_client.call_api('/simengine/rest/capture/{simulation}', 'POST',
                                        path_params,
                                        query_params,
                                        header_params,
                                        body=body_params,
                                        post_params=form_params,
                                        files=local_var_files,
                                        response_type='StdDefsJsondefinitionsnoschema',
                                        auth_settings=auth_settings,
                                        callback=params.get('callback'),
                                        _return_http_data_only=params.get('_return_http_data_only'),
                                        _preload_content=params.get('_preload_content', True),
                                        _request_timeout=params.get('_request_timeout'),
                                        collection_formats=collection_formats)
